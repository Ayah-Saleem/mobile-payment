<!doctype html>
<html lang="ar" dir="rtl">
 <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Vending Machine - State Pattern</title>
  <style>
    body {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100%;
      height: 100%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    html {
      height: 100%;
      width: 100%;
    }

    .machine-container {
      width: 100%;
      max-width: 800px;
      background: white;
      border-radius: 30px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
      text-align: center;
    }

    .machine-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 20px;
      margin-bottom: 30px;
    }

    .machine-title {
      font-size: 36px;
      font-weight: 900;
      margin: 0 0 10px 0;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .machine-subtitle {
      font-size: 18px;
      margin: 0;
      opacity: 0.95;
    }

    .state-display {
      background: linear-gradient(135deg, #f8f9ff 0%, #f0f2ff 100%);
      border: 4px solid #667eea;
      border-radius: 20px;
      padding: 30px;
      margin: 30px 0;
      min-height: 200px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }

    .state-badge {
      display: inline-block;
      padding: 15px 30px;
      border-radius: 50px;
      font-size: 20px;
      font-weight: 900;
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 1px;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    .state-badge.idle { background: #10b981; color: white; }
    .state-badge.product-selected { background: #f59e0b; color: white; }
    .state-badge.waiting-payment { background: #3b82f6; color: white; }
    .state-badge.payment-confirmed { background: #8b5cf6; color: white; }
    .state-badge.dispensing { background: #ec4899; color: white; }
    .state-badge.returning-change { background: #06b6d4; color: white; }
    .state-badge.complete { background: #10b981; color: white; }

    .state-icon {
      font-size: 80px;
      margin: 20px 0;
      animation: float 3s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }

    .state-message {
      font-size: 24px;
      font-weight: 700;
      color: #667eea;
      margin: 15px 0;
    }

    .state-details {
      font-size: 16px;
      color: #6b7280;
      margin: 10px 0;
    }

    .qr-container {
      background: white;
      padding: 30px;
      border-radius: 20px;
      display: inline-block;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      margin: 20px 0;
    }

    #qrcode {
      display: inline-block;
    }

    .info-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-top: 20px;
    }

    .info-card {
      background: linear-gradient(135deg, #f8f9ff 0%, #e0e7ff 100%);
      padding: 20px;
      border-radius: 15px;
      border: 2px solid #c7d2fe;
    }

    .info-label {
      font-size: 14px;
      color: #6b7280;
      font-weight: 600;
      margin-bottom: 8px;
    }

    .info-value {
      font-size: 22px;
      font-weight: 900;
      color: #667eea;
    }

    .complete-message {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 30px;
      border-radius: 20px;
      margin: 20px 0;
      animation: slideIn 0.5s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .complete-icon {
      font-size: 80px;
      margin-bottom: 15px;
    }

    .complete-text {
      font-size: 28px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    .machine-id-display {
      background: rgba(255, 255, 255, 0.2);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 700;
      margin-top: 15px;
    }

    .hidden {
      display: none !important;
    }

    @media (max-width: 768px) {
      .machine-container {
        padding: 20px;
        margin: 20px;
      }

      .machine-title {
        font-size: 28px;
      }

      .info-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="/_sdk/element_sdk.js"></script>
  <style>@view-transition { navigation: auto; }</style>
  <script src="/_sdk/data_sdk.js" type="text/javascript"></script>
  <script src="https://cdn.tailwindcss.com" type="text/javascript"></script>
 </head>
 <body>
  <div class="machine-container">
   <header class="machine-header">
    <h1 class="machine-title">ü§ñ Advanced Vending Machine</h1>
    <p class="machine-subtitle">State Design Pattern Implementation</p>
    <div class="machine-id-display" id="machineIdDisplay">
     Machine: Loading...
    </div>
   </header>
   <div class="state-display" id="stateDisplay">
    <div class="state-badge idle" id="stateBadge">
     IDLE
    </div>
    <div class="state-icon" id="stateIcon">
     üîµ
    </div>
    <div class="state-message" id="stateMessage">
     ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ
    </div>
    <div class="state-details" id="stateDetails">
     ÿßŸÖÿ≥ÿ≠ ÿ±ŸÖÿ≤ QR ŸÑŸÑÿ®ÿØÿ°
    </div>
    <div id="dynamicContent"></div>
   </div>
  </div>
  <script type="module">
    // ============================================
    // 1. STATE DESIGN PATTERN IMPLEMENTATION
    // ============================================
    
    /**
     * Base State Interface (Abstract Class)
     * All concrete states must extend this class
     */
    class State {
      constructor(name) {
        this.name = name;
      }

      /**
       * Called when entering this state
       * @param {VendingMachineContext} context - The state machine context
       */
      enter(context) {
        throw new Error('enter() must be implemented by concrete state');
      }

      /**
       * Called when exiting this state
       * @param {VendingMachineContext} context - The state machine context
       */
      exit(context) {
        // Optional: Can be overridden by concrete states
      }

      /**
       * Handle events in this state
       * @param {Event} event - The event to handle
       * @param {VendingMachineContext} context - The state machine context
       */
      handleEvent(event, context) {
        throw new Error('handleEvent() must be implemented by concrete state');
      }

      /**
       * Get display information for this state
       * @returns {Object} Display information
       */
      getDisplayInfo() {
        throw new Error('getDisplayInfo() must be implemented by concrete state');
      }
    }

    // ============================================
    // CONCRETE STATE CLASSES
    // ============================================

    /**
     * IdleState - Machine is waiting for QR scan
     */
    class IdleState extends State {
      constructor() {
        super('IDLE');
      }

      enter(context) {
        console.log('[STATE] Entering IdleState');
        context.clearSessionData();
        context.view.render(this.getDisplayInfo());
      }

      handleEvent(event, context) {
        if (event.type === 'QR_SCANNED') {
          console.log('[EVENT] QR_SCANNED received in IdleState');
          context.transitionTo(new ProductSelectionState());
        }
      }

      getDisplayInfo() {
        return {
          badge: 'IDLE',
          badgeClass: 'idle',
          icon: 'üîµ',
          message: 'ÿ¨ÿßŸáÿ≤ ŸÑŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ',
          details: 'ÿßŸÖÿ≥ÿ≠ ÿ±ŸÖÿ≤ QR ŸÑŸÑÿ®ÿØÿ°',
          showQR: true
        };
      }
    }

    /**
     * ProductSelectionState - Product has been selected
     */
    class ProductSelectionState extends State {
      constructor() {
        super('PRODUCT_SELECTED');
      }

      enter(context) {
        console.log('[STATE] Entering ProductSelectionState');
        context.view.render(this.getDisplayInfo(context));
      }

      handleEvent(event, context) {
        if (event.type === 'PAYMENT_INITIATED') {
          console.log('[EVENT] PAYMENT_INITIATED received');
          context.sessionData.amountPaid = event.data.amountPaid;
          context.transitionTo(new WaitingPaymentState());
        }
      }

      getDisplayInfo(context) {
        const product = context.sessionData.selectedProduct;
        return {
          badge: 'PRODUCT SELECTED',
          badgeClass: 'product-selected',
          icon: product?.icon || 'üõí',
          message: `ÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ±: ${product?.name || 'ŸÖŸÜÿ™ÿ¨'}`,
          details: `ÿßŸÑÿ≥ÿπÿ±: ${product?.price || 0} ÿ±.ÿ≥`,
          showDetails: true,
          productInfo: product
        };
      }
    }

    /**
     * WaitingPaymentState - Waiting for payment confirmation
     */
    class WaitingPaymentState extends State {
      constructor() {
        super('WAITING_PAYMENT');
      }

      enter(context) {
        console.log('[STATE] Entering WaitingPaymentState');
        context.view.render(this.getDisplayInfo(context));
        
        // Simulate payment processing
        setTimeout(() => {
          context.eventBus.emit('PAYMENT_RECEIVED', {});
        }, 1500);
      }

      handleEvent(event, context) {
        if (event.type === 'PAYMENT_RECEIVED') {
          console.log('[EVENT] PAYMENT_RECEIVED received');
          context.transitionTo(new PaymentConfirmedState());
        }
      }

      getDisplayInfo(context) {
        return {
          badge: 'WAITING PAYMENT',
          badgeClass: 'waiting-payment',
          icon: 'üí≥',
          message: 'ÿ¨ÿßÿ±Ÿä ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿØŸÅÿπ...',
          details: `ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿØŸÅŸàÿπ: ${context.sessionData.amountPaid} ÿ±.ÿ≥`,
          showDetails: true,
          productInfo: context.sessionData.selectedProduct,
          amountPaid: context.sessionData.amountPaid,
          change: context.sessionData.change
        };
      }
    }

    /**
     * PaymentConfirmedState - Payment has been confirmed
     */
    class PaymentConfirmedState extends State {
      constructor() {
        super('PAYMENT_CONFIRMED');
      }

      enter(context) {
        console.log('[STATE] Entering PaymentConfirmedState');
        context.view.render(this.getDisplayInfo(context));
        
        setTimeout(() => {
          context.eventBus.emit('START_DISPENSING', {});
        }, 2000);
      }

      handleEvent(event, context) {
        if (event.type === 'START_DISPENSING') {
          console.log('[EVENT] START_DISPENSING received');
          context.transitionTo(new DispensingState());
        }
      }

      getDisplayInfo(context) {
        return {
          badge: 'PAYMENT CONFIRMED',
          badgeClass: 'payment-confirmed',
          icon: '‚úÖ',
          message: 'ÿ™ŸÖ ÿ™ÿ£ŸÉŸäÿØ ÿßŸÑÿØŸÅÿπ ÿ®ŸÜÿ¨ÿßÿ≠!',
          details: 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ≠ÿ∂Ÿäÿ± ÿ∑ŸÑÿ®ŸÉ...',
          showDetails: true,
          productInfo: context.sessionData.selectedProduct,
          amountPaid: context.sessionData.amountPaid,
          change: context.sessionData.change
        };
      }
    }

    /**
     * DispensingState - Product is being dispensed
     */
    class DispensingState extends State {
      constructor() {
        super('DISPENSING');
      }

      enter(context) {
        console.log('[STATE] Entering DispensingState');
        context.view.render(this.getDisplayInfo(context));
        
        setTimeout(() => {
          if (context.sessionData.change > 0) {
            context.eventBus.emit('DISPENSE_COMPLETE', {});
          } else {
            context.eventBus.emit('TRANSACTION_COMPLETE', {});
          }
        }, 3000);
      }

      handleEvent(event, context) {
        if (event.type === 'DISPENSE_COMPLETE') {
          console.log('[EVENT] DISPENSE_COMPLETE received');
          context.transitionTo(new ReturningChangeState());
        } else if (event.type === 'TRANSACTION_COMPLETE') {
          console.log('[EVENT] TRANSACTION_COMPLETE received');
          context.transitionTo(new CompleteState());
        }
      }

      getDisplayInfo(context) {
        return {
          badge: 'DISPENSING',
          badgeClass: 'dispensing',
          icon: 'üì¶',
          message: 'ÿ¨ÿßÿ±Ÿä ÿ™ÿ¨ŸáŸäÿ≤ ÿßŸÑŸÖŸÜÿ™ÿ¨...',
          details: 'Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿßŸÜÿ™ÿ∏ÿßÿ±',
          showDetails: true,
          productInfo: context.sessionData.selectedProduct
        };
      }
    }

    /**
     * ReturningChangeState - Returning change to customer
     */
    class ReturningChangeState extends State {
      constructor() {
        super('RETURNING_CHANGE');
      }

      enter(context) {
        console.log('[STATE] Entering ReturningChangeState');
        context.view.render(this.getDisplayInfo(context));
        
        setTimeout(() => {
          context.eventBus.emit('CHANGE_RETURNED', {});
        }, 2000);
      }

      handleEvent(event, context) {
        if (event.type === 'CHANGE_RETURNED') {
          console.log('[EVENT] CHANGE_RETURNED received');
          context.transitionTo(new CompleteState());
        }
      }

      getDisplayInfo(context) {
        return {
          badge: 'RETURNING CHANGE',
          badgeClass: 'returning-change',
          icon: 'üí∞',
          message: 'ÿ¨ÿßÿ±Ÿä ÿ•ÿ±ÿ¨ÿßÿπ ÿßŸÑÿ®ÿßŸÇŸä...',
          details: `ÿßŸÑÿ®ÿßŸÇŸä: ${context.sessionData.change} ÿ±.ÿ≥`,
          showDetails: true,
          change: context.sessionData.change
        };
      }
    }

    /**
     * CompleteState - Transaction complete
     */
    class CompleteState extends State {
      constructor() {
        super('COMPLETE');
      }

      enter(context) {
        console.log('[STATE] Entering CompleteState');
        context.view.render(this.getDisplayInfo(context));
        
        setTimeout(() => {
          context.eventBus.emit('RESET_MACHINE', {});
        }, 5000);
      }

      handleEvent(event, context) {
        if (event.type === 'RESET_MACHINE') {
          console.log('[EVENT] RESET_MACHINE received');
          context.transitionTo(new IdleState());
        }
      }

      getDisplayInfo(context) {
        return {
          badge: 'COMPLETE',
          badgeClass: 'complete',
          icon: 'üéâ',
          message: 'ÿßŸÑÿπŸÖŸÑŸäÿ© ŸÖŸÉÿ™ŸÖŸÑÿ©!',
          details: 'ÿßÿ∞Ÿáÿ® ŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ',
          showComplete: true,
          productInfo: context.sessionData.selectedProduct
        };
      }
    }

    // ============================================
    // 2. EVENT-DRIVEN ARCHITECTURE (OBSERVER PATTERN)
    // ============================================

    /**
     * EventBus - Implements Observer Pattern for event handling
     * Decouples input sources from state machine logic
     */
    class EventBus {
      constructor() {
        this.listeners = {};
      }

      /**
       * Emit an event to all listeners
       * @param {string} eventType - The type of event
       * @param {Object} data - Event data
       */
      emit(eventType, data = {}) {
        console.log(`[EVENT_BUS] Emitting event: ${eventType}`, data);
        const event = { type: eventType, data, timestamp: Date.now() };
        
        if (this.listeners[eventType]) {
          this.listeners[eventType].forEach(callback => {
            try {
              callback(event);
            } catch (error) {
              console.error(`[EVENT_BUS] Error in listener for ${eventType}:`, error);
            }
          });
        }
      }

      /**
       * Register a listener for an event type
       * @param {string} eventType - The type of event to listen for
       * @param {Function} callback - The callback function
       */
      on(eventType, callback) {
        if (!this.listeners[eventType]) {
          this.listeners[eventType] = [];
        }
        this.listeners[eventType].push(callback);
        console.log(`[EVENT_BUS] Registered listener for: ${eventType}`);
      }

      /**
       * Remove a listener
       * @param {string} eventType - The type of event
       * @param {Function} callback - The callback to remove
       */
      off(eventType, callback) {
        if (this.listeners[eventType]) {
          this.listeners[eventType] = this.listeners[eventType].filter(cb => cb !== callback);
        }
      }
    }

    // ============================================
    // 3. MODEL-VIEW SEPARATION
    // ============================================

    /**
     * VendingMachineView - Pure View layer (Observer)
     * Only responsible for rendering UI based on Model state
     */
    class VendingMachineView {
      constructor() {
        this.stateBadge = document.getElementById('stateBadge');
        this.stateIcon = document.getElementById('stateIcon');
        this.stateMessage = document.getElementById('stateMessage');
        this.stateDetails = document.getElementById('stateDetails');
        this.dynamicContent = document.getElementById('dynamicContent');
        this.qrCode = null;
      }

      /**
       * Render the view based on state information
       * @param {Object} displayInfo - Information from current state
       */
      render(displayInfo) {
        console.log('[VIEW] Rendering:', displayInfo);

        // Update state badge
        this.stateBadge.textContent = displayInfo.badge;
        this.stateBadge.className = `state-badge ${displayInfo.badgeClass}`;

        // Update icon
        this.stateIcon.textContent = displayInfo.icon;

        // Update message and details
        this.stateMessage.textContent = displayInfo.message;
        this.stateDetails.textContent = displayInfo.details;

        // Clear dynamic content
        this.dynamicContent.innerHTML = '';

        // Show QR Code if needed
        if (displayInfo.showQR) {
          this.renderQRCode();
        }

        // Show product details if needed
        if (displayInfo.showDetails && displayInfo.productInfo) {
          this.renderProductDetails(displayInfo);
        }

        // Show complete message if needed
        if (displayInfo.showComplete) {
          this.renderCompleteMessage(displayInfo);
        }
      }

      /**
       * Render QR Code
       */
      renderQRCode() {
        const qrContainer = document.createElement('div');
        qrContainer.className = 'qr-container';
        qrContainer.id = 'qrCodeContainer';
        
        const qrDiv = document.createElement('div');
        qrDiv.id = 'qrcode';
        qrContainer.appendChild(qrDiv);
        
        this.dynamicContent.appendChild(qrContainer);

        // Generate QR Code
        const machineId = window.MACHINE_ID || 'VM-001';
        const qrUrl = `${window.location.origin}${window.location.pathname.replace('index.html', '')}mobile.html?machine=${machineId}`;
        
        if (this.qrCode) {
          qrDiv.innerHTML = '';
        }
        
        this.qrCode = new QRCode(qrDiv, {
          text: qrUrl,
          width: 200,
          height: 200,
          colorDark: "#667eea",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.H
        });
      }

      /**
       * Render product details
       */
      renderProductDetails(displayInfo) {
        const detailsHTML = `
          <div class="info-grid">
            <div class="info-card">
              <div class="info-label">ÿßŸÑŸÖŸÜÿ™ÿ¨</div>
              <div class="info-value">${displayInfo.productInfo.icon} ${displayInfo.productInfo.name}</div>
            </div>
            <div class="info-card">
              <div class="info-label">ÿßŸÑÿ≥ÿπÿ±</div>
              <div class="info-value">${displayInfo.productInfo.price} ÿ±.ÿ≥</div>
            </div>
            ${displayInfo.amountPaid ? `
              <div class="info-card">
                <div class="info-label">ÿßŸÑŸÖÿ®ŸÑÿ∫ ÿßŸÑŸÖÿØŸÅŸàÿπ</div>
                <div class="info-value">${displayInfo.amountPaid} ÿ±.ÿ≥</div>
              </div>
              <div class="info-card">
                <div class="info-label">ÿßŸÑÿ®ÿßŸÇŸä</div>
                <div class="info-value">${displayInfo.change} ÿ±.ÿ≥</div>
              </div>
            ` : ''}
          </div>
        `;
        this.dynamicContent.innerHTML += detailsHTML;
      }

      /**
       * Render complete message
       */
      renderCompleteMessage(displayInfo) {
        const completeHTML = `
          <div class="complete-message">
            <div class="complete-icon">‚úÖ</div>
            <div class="complete-text">ÿ™ŸÖ ÿßŸÑÿØŸÅÿπ ÿ®ŸÜÿ¨ÿßÿ≠!</div>
            <div style="font-size: 18px; margin-top: 10px;">
              ${displayInfo.productInfo.icon} ${displayInfo.productInfo.name}
            </div>
            <div style="font-size: 22px; margin-top: 15px; font-weight: 700;">
              üéÅ ÿßÿ∞Ÿáÿ® ŸÑÿßÿ≥ÿ™ŸÑÿßŸÖ ÿ∑ŸÑÿ®ŸÉ ÿßŸÑÿ¢ŸÜ!
            </div>
          </div>
        `;
        this.dynamicContent.innerHTML = completeHTML;
      }
    }

    /**
     * VendingMachineContext - The State Machine (Model)
     * Pure logic without any UI dependencies
     */
    class VendingMachineContext {
      constructor(view, eventBus, machineId) {
        this.view = view;
        this.eventBus = eventBus;
        this.machineId = machineId;
        this.currentState = null;
        this.sessionData = {
          selectedProduct: null,
          amountPaid: 0,
          change: 0
        };

        // Register as observer of events
        this.registerEventHandlers();

        // Start in Idle state
        this.transitionTo(new IdleState());
      }

      /**
       * Register event handlers (Observer Pattern)
       */
      registerEventHandlers() {
        // Listen to all event types
        const eventTypes = [
          'QR_SCANNED',
          'PRODUCT_SELECTED',
          'PAYMENT_INITIATED',
          'PAYMENT_RECEIVED',
          'START_DISPENSING',
          'DISPENSE_COMPLETE',
          'CHANGE_RETURNED',
          'TRANSACTION_COMPLETE',
          'RESET_MACHINE'
        ];

        eventTypes.forEach(eventType => {
          this.eventBus.on(eventType, (event) => {
            if (this.currentState) {
              this.currentState.handleEvent(event, this);
            }
          });
        });
      }

      /**
       * Transition to a new state
       * @param {State} newState - The new state to transition to
       */
      transitionTo(newState) {
        console.log(`[STATE_MACHINE] Transitioning from ${this.currentState?.name || 'null'} to ${newState.name}`);
        
        // Exit current state
        if (this.currentState) {
          this.currentState.exit(this);
        }

        // Update current state
        this.currentState = newState;

        // Enter new state
        this.currentState.enter(this);

        // Update Firebase
        this.syncWithFirebase();
      }

      /**
       * Clear session data
       */
      clearSessionData() {
        this.sessionData = {
          selectedProduct: null,
          amountPaid: 0,
          change: 0
        };
      }

      /**
       * Sync state with Firebase
       */
      async syncWithFirebase() {
        if (!window.firebaseDatabase) return;

        try {
          const sessionRef = window.firebaseRef(window.firebaseDatabase, `sessions/${this.machineId}`);
          await window.firebaseSet(sessionRef, {
            state: this.currentState.name,
            timestamp: Date.now(),
            selectedProductId: this.sessionData.selectedProduct?.id || null,
            selectedProductName: this.sessionData.selectedProduct?.name || null,
            selectedProductIcon: this.sessionData.selectedProduct?.icon || null,
            selectedProductPrice: this.sessionData.selectedProduct?.price || 0,
            amountPaid: this.sessionData.amountPaid,
            change: this.sessionData.change
          });
        } catch (error) {
          console.error('[FIREBASE] Sync error:', error);
        }
      }

      /**
       * Update session data from external source (Firebase)
       */
      updateSessionData(data) {
        if (data.selectedProductId) {
          this.sessionData.selectedProduct = {
            id: data.selectedProductId,
            name: data.selectedProductName,
            icon: data.selectedProductIcon,
            price: data.selectedProductPrice
          };
        }
        
        if (data.amountPaid !== undefined) {
          this.sessionData.amountPaid = data.amountPaid;
        }
        
        if (data.change !== undefined) {
          this.sessionData.change = data.change;
        }
      }
    }

    // ============================================
    // 4. FIREBASE INTEGRATION
    // ============================================

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyBSaulFhBLOd9KP0BkZXNdh0OFv4GACUPU",
      authDomain: "vending-machine-b7af8.firebaseapp.com",
      databaseURL: "https://vending-machine-b7af8-default-rtdb.firebaseio.com",
      projectId: "vending-machine-b7af8",
      storageBucket: "vending-machine-b7af8.firebasestorage.app",
      messagingSenderId: "242706996040",
      appId: "1:242706996040:web:b88f48fdd5bf5c21929c23"
    };

    // Load Firebase
    const script1 = document.createElement('script');
    script1.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js';
    document.head.appendChild(script1);

    const script2 = document.createElement('script');
    script2.src = 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js';
    document.head.appendChild(script2);

    // Initialize Application
    script2.onload = () => {
      // Initialize Firebase
      firebase.initializeApp(firebaseConfig);
      window.firebaseDatabase = firebase.database();
      window.firebaseRef = firebase.database().ref.bind(firebase.database());
      window.firebaseSet = (ref, data) => ref.set(data);
      window.firebaseOnValue = (ref, callback) => ref.on('value', callback);

      // Get Machine ID
      const urlParams = new URLSearchParams(window.location.search);
      window.MACHINE_ID = urlParams.get('machine') || 'VM-001';
      document.getElementById('machineIdDisplay').textContent = `Machine: ${window.MACHINE_ID}`;

      // Initialize the system
      const view = new VendingMachineView();
      const eventBus = new EventBus();
      const stateMachine = new VendingMachineContext(view, eventBus, window.MACHINE_ID);

      // Listen to Firebase changes
      const sessionRef = window.firebaseRef(window.firebaseDatabase, `sessions/${window.MACHINE_ID}`);
      window.firebaseOnValue(sessionRef, (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        console.log('[FIREBASE] Received update:', data);

        // Update session data
        stateMachine.updateSessionData(data);

        // Handle state-specific events from Firebase
        if (data.state === 'PRODUCT_SELECTED' && stateMachine.currentState.name === 'IDLE') {
          eventBus.emit('QR_SCANNED', {});
        } else if (data.state === 'WAITING_PAYMENT' && stateMachine.currentState.name === 'PRODUCT_SELECTED') {
          eventBus.emit('PAYMENT_INITIATED', { amountPaid: data.amountPaid });
        }
      });

      console.log('[SYSTEM] Vending Machine initialized successfully');
      console.log('[SYSTEM] State Pattern: ‚úÖ Implemented');
      console.log('[SYSTEM] Event-Driven Architecture: ‚úÖ Implemented');
      console.log('[SYSTEM] Model-View Separation: ‚úÖ Implemented');
    };

    // Initialize Elements SDK
    if (window.elementSdk) {
      const defaultConfig = {
        primary_color: "#667eea",
        secondary_color: "#764ba2"
      };

      window.elementSdk.init({
        defaultConfig: defaultConfig,
        onConfigChange: async (config) => {},
        mapToCapabilities: (config) => ({
          recolorables: [],
          borderables: [],
          fontEditable: undefined,
          fontSizeable: undefined
        }),
        mapToEditPanelValues: (config) => new Map()
      });
    }
  </script>
 <script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'9a8640a6c26a5dab',t:'MTc2NDc5ODM0Mi4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
